[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learners Paradigm",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html",
    "href": "chapters_dir/chapters/01-basics.html",
    "title": "3  Basics",
    "section": "",
    "text": "4 C Basics",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#the-structure-of-a-c-program",
    "href": "chapters_dir/chapters/01-basics.html#the-structure-of-a-c-program",
    "title": "3  Basics",
    "section": "4.1 The Structure of a C Program",
    "text": "4.1 The Structure of a C Program\nLet’s start with a simple “Hello, World!” program:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nLet’s break this down:\n#include &lt;stdio.h&gt; - This is a preprocessor directive that includes the standard input/output library.\nint main() - The main function, which is the entry point of every C program.\nprintf(\"Hello, World!\\n\"); - A function call that prints text to the console.\nreturn 0; - Returns 0 to the operating system, indicating successful execution.\n{ } - Curly braces define code blocks.\n\nComments in C:\nC supports two types of comments:\n// This is a single-line comment\n\n/* This is a multi-line comment\n   that spans across several lines */\nComments are ignored by the compiler and are used to explain your code.\n\nPreprocessor Directives:\nPreprocessor directives start with # and are processed before compilation:\n#include &lt;stdio.h&gt;  // Include a header file\n#define PI 3.14159  // Define a constant\nCommon preprocessor directives:\n#include- Includes a header file\n#define- Defines a constant or macro\n`#ifdef, #ifndef, #endif - Conditional compilation\n\nCompilation Process:\nThe C compilation process involves four stages:\n\nPreprocessing: Processes directives like #include and #define\nCompilation: Converts source code to assembly code\nAssembly: Converts assembly code to object code\nLinking: Combines object files and libraries into an executable\n\n\n\n\nsrc : 3\n\n\n\nLet’s revisit our “Hello World” program:\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nprintf() is a function from the standard library that outputs formatted text\n\\n is an escape sequence representing a newline character\nThe semicolon ; ends each statement\n\nExercise: Writing our First C Program\nSteps:\nCreate a file named greeting.c\nWrite a program that prints “Hello, [your name]!”\nCompile and run the program\nSolution:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, [your name]!\\n\");\n    return 0;\n}\nCompile and run:\n #macOS\ngcc greeting.c -o greeting\n./greeting",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#variables-and-data-types",
    "href": "chapters_dir/chapters/01-basics.html#variables-and-data-types",
    "title": "3  Basics",
    "section": "4.2 Variables and Data Types",
    "text": "4.2 Variables and Data Types\n\n4.2.1 Basic Data Types\nC provides several fundamental data types:\n\n\n\n\n\n\n\n\n\nType\nDescription\nFormat Specifier\nExample\n\n\n\n\nint\nInteger\n%d or %i\nint age = 25;\n\n\nfloat\nSingle-precision floating-point\n%f\nfloat price = 19.99f;\n\n\ndouble\nDouble-precision floating-point\n%lf\ndouble pi = 3.14159265359;\n\n\nchar\nSingle character\n%c\nchar grade = 'A';\n\n\n\n\n\n4.2.2 Variable Declaration and Initialization\nVariables must be declared before use:\n// Declaration only\nint count;\n\n// Declaration with initialization\nint count = 0;\n\n// Multiple variables of the same type\nint x, y, z;\nint a = 1, b = 2, c = 3;\n\n\n4.2.3 Type Modifiers\nType modifiers alter the range or behavior of basic types:\n\n\n\n\n\n\n\n\nModifier\nDescription\nExample\n\n\n\n\nshort\nReduced-size integer\nshort int num = 123;\n\n\nlong\nExtended-size integer\nlong int population = 7800000000L;\n\n\nunsigned\nNon-negative values only\nunsigned int count = 50;\n\n\nsigned\nPositive and negative values (default)\nsigned int temperature = -10;\n\n\n\n\n\n4.2.4 Constants\nConstants are values that cannot be modified after declaration:\n// Using const qualifier\nconst float PI = 3.14159;\n\n// Using #define preprocessor directive\n#define MAX_SIZE 100",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#type-conversion",
    "href": "chapters_dir/chapters/01-basics.html#type-conversion",
    "title": "3  Basics",
    "section": "4.3 Type Conversion",
    "text": "4.3 Type Conversion\nC supports two types of type conversion:\n\nImplicit conversion (automatic):\nint x = 10;\ndouble y = x;  // int implicitly converted to double\nExplicit conversion (casting):\ndouble x = 10.5;\nint y = (int)x;  // x is explicitly cast to int, y = 10",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#variable-scope",
    "href": "chapters_dir/chapters/01-basics.html#variable-scope",
    "title": "3  Basics",
    "section": "4.4 Variable Scope",
    "text": "4.4 Variable Scope\nThe scope of a variable determines where it can be accessed:\n\nLocal variables - Declared inside a function and accessible only within that function\nGlobal variables - Declared outside any function and accessible throughout the program\nBlock-level variables - Declared inside a block and accessible only within that block\n\n#include &lt;stdio.h&gt;\n\n// Global variable\nint globalVar = 100;\n\nint main() {\n    // Local variable\n    int localVar = 50;\n    \n    {\n        // Block-level variable\n        int blockVar = 25;\n        printf(\"Block variable: %d\\n\", blockVar);\n    }\n    \n    // blockVar is not accessible here\n    \n    printf(\"Global variable: %d\\n\", globalVar);\n    printf(\"Local variable: %d\\n\", localVar);\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#memory-size-and-range",
    "href": "chapters_dir/chapters/01-basics.html#memory-size-and-range",
    "title": "3  Basics",
    "section": "4.5 Memory Size and Range",
    "text": "4.5 Memory Size and Range\nThe sizeof() operator returns the memory size (in bytes) of a data type or variable:\n#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;  // For integer limits\n#include &lt;float.h&gt;   // For floating-point limits\n\nint main() {\n    printf(\"Size of int: %zu bytes\\n\", sizeof(int));\n    printf(\"Range of int: %d to %d\\n\", INT_MIN, INT_MAX);\n    \n    printf(\"Size of float: %zu bytes\\n\", sizeof(float));\n    printf(\"Range of float: %e to %e\\n\", FLT_MIN, FLT_MAX);\n    \n    return 0;\n}\nOutput:\nvaibhav@Mac src % gcc memory_size.c -o out\nvaibhav@Mac src % ./out\nSize of int: 4 bytes\nRange of int: -2147483648 to 2147483647\nSize of float: 4 bytes\nRange of float: 1.175494e-38 to 3.402823e+38",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#exercise-working-with-variables",
    "href": "chapters_dir/chapters/01-basics.html#exercise-working-with-variables",
    "title": "3  Basics",
    "section": "4.6 Exercise: Working with Variables",
    "text": "4.6 Exercise: Working with Variables\nWrite a program that:\n\nDeclares variables for a person’s name, age, and height\nInitializes them with values\nPrints them in a formatted way\n\nSolution:\n#include &lt;stdio.h&gt;\n\nint main() {\n    // Declare and initialize variables\n    char name[50] = \"John Doe\";\n    int age = 30;\n    float height = 175.5;  // in cm\n    \n    // Print the values\n    printf(\"Name: %s\\n\", name);\n    printf(\"Age: %d years\\n\", age);\n    printf(\"Height: %.1f cm\\n\", height);\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#operators-in-c",
    "href": "chapters_dir/chapters/01-basics.html#operators-in-c",
    "title": "3  Basics",
    "section": "4.7 Operators in C",
    "text": "4.7 Operators in C",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#arithmetic-operators",
    "href": "chapters_dir/chapters/01-basics.html#arithmetic-operators",
    "title": "3  Basics",
    "section": "4.8 Arithmetic Operators",
    "text": "4.8 Arithmetic Operators\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n+\nAddition\na + b\n\n\n-\nSubtraction\na - b\n\n\n*\nMultiplication\na * b\n\n\n/\nDivision\na / b\n\n\n%\nModulus (remainder)\na % b\n\n\n++\nIncrement\na++ or ++a\n\n\n--\nDecrement\na-- or --a\n\n\n\n\n4.8.1 Example:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10, b = 3;\n    \n    printf(\"a + b = %d\\n\", a + b);  // 13\n    printf(\"a - b = %d\\n\", a - b);  // 7\n    printf(\"a * b = %d\\n\", a * b);  // 30\n    printf(\"a / b = %d\\n\", a / b);  // 3 (integer division)\n    printf(\"a %% b = %d\\n\", a % b); // 1 (remainder)\n    \n    int c = a++;  // c = 10, then a becomes 11\n    int d = ++b;  // b becomes 4, then d = 4\n    \n    printf(\"After a++: a = %d, c = %d\\n\", a, c);\n    printf(\"After ++b: b = %d, d = %d\\n\", b, d);\n    \n    return 0;\n}\n\n/*\nhttps://www.programiz.com/c-programming/online-compiler/\nOutput:\na + b = 13\na - b = 7\na * b = 30\na / b = 3\na % b = 1\nAfter a++: a = 11, c = 10\nAfter ++b: b = 4, d = 4\n\n\n=== Code Execution Successful ===\n*/",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#assignment-operators",
    "href": "chapters_dir/chapters/01-basics.html#assignment-operators",
    "title": "3  Basics",
    "section": "4.9 Assignment Operators",
    "text": "4.9 Assignment Operators\n\n\n\nOperator\nDescription\nEquivalent to\n\n\n\n\n=\nSimple assignment\na = b\n\n\n+=\nAdd and assign\na = a + b\n\n\n-=\nSubtract and assign\na = a - b\n\n\n*=\nMultiply and assign\na = a * b\n\n\n/=\nDivide and assign\na = a / b\n\n\n%=\nModulus and assign\na = a % b\n\n\n\n\n4.9.1 Example:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n    \n    x += 5;  // x = x + 5\n    printf(\"After x += 5: x = %d\\n\", x);  // 15\n    \n    x -= 3;  // x = x - 3\n    printf(\"After x -= 3: x = %d\\n\", x);  // 12\n    \n    x *= 2;  // x = x * 2\n    printf(\"After x *= 2: x = %d\\n\", x);  // 24\n    \n    x /= 4;  // x = x / 4\n    printf(\"After x /= 4: x = %d\\n\", x);  // 6\n    \n    x %= 4;  // x = x % 4\n    printf(\"After x %%= 4: x = %d\\n\", x);  // 2\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#comparison-operators",
    "href": "chapters_dir/chapters/01-basics.html#comparison-operators",
    "title": "3  Basics",
    "section": "4.10 Comparison Operators",
    "text": "4.10 Comparison Operators\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n==\nEqual to\na == b\n\n\n!=\nNot equal to\na != b\n\n\n&gt;\nGreater than\na &gt; b\n\n\n&lt;\nLess than\na &lt; b\n\n\n&gt;=\nGreater than or equal to\na &gt;= b\n\n\n&lt;=\nLess than or equal to\na &lt;= b\n\n\n\n\n4.10.1 Example:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10, b = 20;\n    \n    printf(\"a == b: %d\\n\", a == b);  // 0 (false)\n    printf(\"a != b: %d\\n\", a != b);  // 1 (true)\n    printf(\"a &gt; b: %d\\n\", a &gt; b);    // 0 (false)\n    printf(\"a &lt; b: %d\\n\", a &lt; b);    // 1 (true)\n    printf(\"a &gt;= b: %d\\n\", a &gt;= b);  // 0 (false)\n    printf(\"a &lt;= b: %d\\n\", a &lt;= b);  // 1 (true)\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#logical-operators",
    "href": "chapters_dir/chapters/01-basics.html#logical-operators",
    "title": "3  Basics",
    "section": "4.11 Logical Operators",
    "text": "4.11 Logical Operators\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n&&\nLogical AND\na && b\n\n\n\\|\nLogical OR\na \\| b\n\n\n!\nLogical NOT\n!a\n\n\n\n\n4.11.1 Example:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 1, b = 0;  // 1 is true, 0 is false in C\n    \n    printf(\"a && b: %d\\n\", a && b);    // 0 (false)\n    printf(\"a || b: %d\\n\", a || b);    // 1 (true)\n    printf(\"!a: %d\\n\", !a);            // 0 (false)\n    printf(\"!b: %d\\n\", !b);            // 1 (true)\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#bitwise-operators",
    "href": "chapters_dir/chapters/01-basics.html#bitwise-operators",
    "title": "3  Basics",
    "section": "4.12 Bitwise Operators",
    "text": "4.12 Bitwise Operators\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n&\nBitwise AND\na & b\n\n\n\\|\nBitwise OR\na \\| b\n\n\n^\nBitwise XOR\na ^ b\n\n\n~\nBitwise NOT\n~a\n\n\n&lt;&lt;\nLeft shift\na &lt;&lt; n\n\n\n&gt;&gt;\nRight shift\na &gt;&gt; n\n\n\n\n\n4.12.1 Example:\n#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned int a = 60;  // 00111100 in binary\n    unsigned int b = 13;  // 00001101 in binary\n    \n    printf(\"a & b = %u\\n\", a & b);    // 12 (00001100)\n    printf(\"a | b = %u\\n\", a | b);    // 61 (00111101)\n    printf(\"a ^ b = %u\\n\", a ^ b);    // 49 (00110001)\n    printf(\"~a = %u\\n\", ~a);          // 4294967235 (11...00011)\n    printf(\"a &lt;&lt; 2 = %u\\n\", a &lt;&lt; 2);  // 240 (11110000)\n    printf(\"a &gt;&gt; 2 = %u\\n\", a &gt;&gt; 2);  // 15 (00001111)\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#miscellaneous-operators",
    "href": "chapters_dir/chapters/01-basics.html#miscellaneous-operators",
    "title": "3  Basics",
    "section": "4.13 Miscellaneous Operators",
    "text": "4.13 Miscellaneous Operators\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nsizeof\nSize of variable/type\nsizeof(a)\n\n\n&\nAddress of variable\n&a\n\n\n*\nPointer to variable\n*a\n\n\n?:\nConditional operator\na ? b : c\n\n\n\n\n4.13.1 Example:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10;\n    int *ptr = &a;  // ptr holds the address of a\n    \n    printf(\"Size of int: %zu bytes\\n\", sizeof(int));\n    printf(\"Address of a: %p\\n\", &a);\n    printf(\"Value at address stored in ptr: %d\\n\", *ptr);\n    \n    // Conditional operator\n    int max = (a &gt; 20) ? a : 20;\n    printf(\"Max of a and 20: %d\\n\", max);\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#operator-precedence",
    "href": "chapters_dir/chapters/01-basics.html#operator-precedence",
    "title": "3  Basics",
    "section": "4.14 Operator Precedence",
    "text": "4.14 Operator Precedence\nOperators have different precedence levels that determine the order of evaluation:\n\nPostfix ++ -- () [] . -&gt;\nPrefix ++ -- + - ! ~ (type) * & sizeof\nMultiplicative * / %\nAdditive + -\nShift &lt;&lt; &gt;&gt;\nRelational &lt; &lt;= &gt; &gt;=\nEquality == !=\nBitwise AND &\nBitwise XOR ^\nBitwise OR |\nLogical AND &&\nLogical OR ||\nConditional ?:\nAssignment = += -= *= /= %= etc.\n\nWhen in doubt, use parentheses to explicitly specify the order of operations.",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#exercise-temperature-converter",
    "href": "chapters_dir/chapters/01-basics.html#exercise-temperature-converter",
    "title": "3  Basics",
    "section": "4.15 Exercise: Temperature Converter",
    "text": "4.15 Exercise: Temperature Converter\nWrite a program that converts temperature from Fahrenheit to Celsius and vice versa.\nSolution:\n#include &lt;stdio.h&gt;\n\nint main() {\n    float fahrenheit, celsius;\n    \n    // Fahrenheit to Celsius\n    printf(\"Enter temperature in Fahrenheit: \");\n    scanf(\"%f\", &fahrenheit);\n    \n    celsius = (fahrenheit - 32) * 5 / 9;\n    printf(\"%.2f°F = %.2f°C\\n\", fahrenheit, celsius);\n    \n    // Celsius to Fahrenheit\n    printf(\"\\nEnter temperature in Celsius: \");\n    scanf(\"%f\", &celsius);\n    \n    fahrenheit = (celsius * 9 / 5) + 32;\n    printf(\"%.2f°C = %.2f°F\\n\", celsius, fahrenheit);\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#control-structures",
    "href": "chapters_dir/chapters/01-basics.html#control-structures",
    "title": "3  Basics",
    "section": "4.16 Control Structures",
    "text": "4.16 Control Structures\nControl structures allow you to control the flow of execution in your program based on conditions or to repeat a block of code.",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#conditional-statements",
    "href": "chapters_dir/chapters/01-basics.html#conditional-statements",
    "title": "3  Basics",
    "section": "4.17 Conditional Statements",
    "text": "4.17 Conditional Statements\n\n4.17.1 if Statement\nThe if statement executes a block of code if a specified condition is true:\nif (condition) {\n    // Code to execute if condition is true\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int age = 20;\n    \n    if (age &gt;= 18) {\n        printf(\"You are an adult.\\n\");\n    }\n    \n    return 0;\n}\n\n\n4.17.2 if-else Statement\nThe if-else statement executes one block if the condition is true and another if it’s false:\nif (condition) {\n    // Code to execute if condition is true\n} else {\n    // Code to execute if condition is false\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int age = 15;\n    \n    if (age &gt;= 18) {\n        printf(\"You are an adult.\\n\");\n    } else {\n        printf(\"You are a minor.\\n\");\n    }\n    \n    return 0;\n}\n\n\n4.17.3 if-else if-else Statement\nYou can check multiple conditions using if-else if-else:\nif (condition1) {\n    // Code to execute if condition1 is true\n} else if (condition2) {\n    // Code to execute if condition1 is false and condition2 is true\n} else {\n    // Code to execute if all conditions are false\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int score = 85;\n    \n    if (score &gt;= 90) {\n        printf(\"Grade: A\\n\");\n    } else if (score &gt;= 80) {\n        printf(\"Grade: B\\n\");\n    } else if (score &gt;= 70) {\n        printf(\"Grade: C\\n\");\n    } else if (score &gt;= 60) {\n        printf(\"Grade: D\\n\");\n    } else {\n        printf(\"Grade: F\\n\");\n    }\n    \n    return 0;\n}\n\n\n4.17.4 Nested if Statements\nYou can place if statements inside other if or else blocks:\nif (condition1) {\n    if (condition2) {\n        // Code to execute if both conditions are true\n    }\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int age = 25;\n    char hasLicense = 'Y';\n    \n    if (age &gt;= 18) {\n        if (hasLicense == 'Y') {\n            printf(\"You can drive.\\n\");\n        } else {\n            printf(\"You need a license to drive.\\n\");\n        }\n    } else {\n        printf(\"You are too young to drive.\\n\");\n    }\n    \n    return 0;\n}\n\n\n4.17.5 Conditional (Ternary) Operator\nThe conditional operator is a shorthand for simple if-else statements:\nresult = (condition) ? value_if_true : value_if_false;\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int age = 20;\n    char *status = (age &gt;= 18) ? \"adult\" : \"minor\";\n    \n    printf(\"You are a %s.\\n\", status);\n    \n    return 0;\n}\n\n\n4.17.6 switch Statement\nThe switch statement selects one of many code blocks to execute:\nswitch (expression) {\n    case value1:\n        // Code to execute if expression equals value1\n        break;\n    case value2:\n        // Code to execute if expression equals value2\n        break;\n    default:\n        // Code to execute if expression doesn't match any case\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int day = 3;\n    \n    switch (day) {\n        case 1:\n            printf(\"Monday\\n\");\n            break;\n        case 2:\n            printf(\"Tuesday\\n\");\n            break;\n        case 3:\n            printf(\"Wednesday\\n\");\n            break;\n        case 4:\n            printf(\"Thursday\\n\");\n            break;\n        case 5:\n            printf(\"Friday\\n\");\n            break;\n        case 6:\n            printf(\"Saturday\\n\");\n            break;\n        case 7:\n            printf(\"Sunday\\n\");\n            break;\n        default:\n            printf(\"Invalid day\\n\");\n    }\n    \n    return 0;\n}",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#loops",
    "href": "chapters_dir/chapters/01-basics.html#loops",
    "title": "3  Basics",
    "section": "4.18 Loops",
    "text": "4.18 Loops\n\n4.18.1 while Loop\nThe while loop executes a block of code as long as a specified condition is true:\nwhile (condition) {\n    // Code to execute while condition is true\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int i = 1;\n    \n    while (i &lt;= 5) {\n        printf(\"%d \", i);\n        i++;\n    }\n    // Output: 1 2 3 4 5\n    \n    return 0;\n}\n\n\n4.18.2 do-while Loop\nThe do-while loop is similar to the while loop, but it executes the code block once before checking the condition:\ndo {\n    // Code to execute at least once\n} while (condition);\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    int i = 1;\n    \n    do {\n        printf(\"%d \", i);\n        i++;\n    } while (i &lt;= 5);\n    // Output: 1 2 3 4 5\n    \n    return 0;\n}\n\n\n4.18.3 for Loop\nThe for loop provides a concise way to write the loop structure:\nfor (initialization; condition; increment/decrement) {\n    // Code to execute while condition is true\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 5; i++) {\n        printf(\"%d \", i);\n    }\n    // Output: 1 2 3 4 5\n    \n    return 0;\n}\n\n\n4.18.4 Nested Loops\nYou can place loops inside other loops:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        // Code to execute\n    }\n}\nExample:\n#include &lt;stdio.h&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 3; i++) {\n        for (int j = 1; j &lt;= 3; j++) {\n            printf(\"(%d,%d) \", i, j);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\nOutput:\n(1,1) (1,2) (1,3) \n(2,1) (2,2) (2,3) \n(3,1) (3,2) (3,3)",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#jump-statements",
    "href": "chapters_dir/chapters/01-basics.html#jump-statements",
    "title": "3  Basics",
    "section": "4.19 Jump Statements",
    "text": "4.19 Jump Statements\n\n4.19.1 break Statement\nThe break statement terminates the innermost enclosing loop or switch statement:\n#include &lt;stdio.h&gt;\n\nint main() {\n    for (int i = 1; i &lt;= 10; i++) {\n        if (i == 6) {\n            break;  // Exit the loop when i equals 6\n        }\n        printf(\"%d \", i);\n    }\n    // Output: 1 2 3 4 5\n    \n    return 0;",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/01-basics.html#functions",
    "href": "chapters_dir/chapters/01-basics.html#functions",
    "title": "3  Basics",
    "section": "4.20 Functions",
    "text": "4.20 Functions\nA function provides a convenient way to encapsulate some computation, which can then be used without worrying about its implementation. With properly designed functions, it is possible to ignore how a job is done; knowing what is done is sufficient. C makes the sue of functions easy, convinient and efficient; you will often see a short function defined and called only once, just because it clarifies some piece of code. ![src]\nA function definition has this form:\nreturn-type function-name(parameter declarations, if any)\n{\n declarations\n statements\n}\nRewrite function to calculate temperature\n#include &lt;stdio.h&gt;\n\n// Function declaration (prototype)\nint convert_temperature(float fahr);\n\nint main() {\n    int result = convert_temperature(5.0);\n    printf(\"celsius: %d\\n\", result);\n    return 0;\n}\n\n// Function definition\nint convert_temperature(float fahr) {\n    float celsius = 5*(fahr-32)/9;\n    return celsius;\n}\nIf you notice in above example there’s something known as function declaration. This declaration, which is called a function prototype, has to agree with the definition and uses of power. It is an error if the definition of a function or any uses of it do not agree with its prototype. parameter names need not agree. Indeed, parameter names are optional in a function prototype, so for the prototype we could have written\nint convert_temperature(float);\n\nFurther Reading:\n\nChapter 4, C by K&R",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/02-pointers.html",
    "href": "chapters_dir/chapters/02-pointers.html",
    "title": "4  Pointers",
    "section": "",
    "text": "5 Pointers",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pointers</span>"
    ]
  },
  {
    "objectID": "chapters_dir/chapters/02-pointers.html#introduction",
    "href": "chapters_dir/chapters/02-pointers.html#introduction",
    "title": "4  Pointers",
    "section": "5.1 Introduction:",
    "text": "5.1 Introduction:\nPointers require a separate chapter altogether because I feel pointers in C provides a powerfu mechanism to interact with memory management.\nIn short, pointers are variables which store memory address to other variables.\n\n5.1.1 Pointers and Addresses\nFrom C by K&R:\nLet us begin with a simplified picture of how memory is organized. A typical machine has an array of consecutively numbered or addressed memory cells that may be manipulated individually or in contiguous groups. One common situation is that any byte can be a char, a pair of one-byte cells can be treated as a short integer, and four adjacent bytes form a long. A pointer is a group of cells (often two or four) that can hold an address. So if c is a char and p is a pointer that points to it, we could represent the situation this way:\n\n\n\nsrc : C by K&R\n\n\nIn order to make variable ‘p’ point to the memory address of variable ‘c’\np = &c;\nThe & operator only applies to objects in memory: variables and array elements. It cannot be applied to expressions, constants, or register variables.\nExample code:\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10; // integer a contains 10 as value\n    int *p; //define a pointer variable p , * operator is the indirection or dereferencing operator; when applied to a pointer, it\n            //accesses the object the pointer points to.\n    \n    p = &a; // this line means pointer p is said to 'point to' a\n    printf(\"%d\",p); \n    \n    return 0;\n}\n\n/*\nFrom: https://www.programiz.com/c-programming/online-compiler/\nOutput:\n1539960324\n\n=== Code Execution Successful ===\n*/\nSo in essence, int x = 1 being a generic integer assignment can be operated on using a pointer variable as shown below\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10; // integer a contains 10 as value\n    int *p; //define a pointer variable p , * operator is the indirection or dereferencing operator; when applied to a pointer, it\n            //accesses the object the pointer points to.\n    \n    p = &a; // this line means pointer p is said to 'point to' a\n    printf(\"%d \\n\",p); \n    \n    //use a third variable B\n    int b = *p; //this assigns the value at memory address 'pointed by' p to integer variable b\n    \n    printf(\"B is : %d\\n\",b);\n\n    *p=1;\n    printf(\"a is : %d\\n\",a);\n    printf(\"b is : %d\\n\",b);\n\n\n    return 0;\n}\n\n/* output from https://www.programiz.com/c-programming/online-compiler/\n1729765392 \nB is : 10\na is : 1\nb is : 10\n\n\n=== Code Execution Successful ===\n*/\n\nIn no way this covers pointers, rather this is hardly an introduction. But the point it to learn by doing . I’ll ensure to add some highlighted notes in further chapters where pointer play a key role.",
    "crumbs": [
      "__init__",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pointers</span>"
    ]
  },
  {
    "objectID": "chapters_dir/2_storing_data_elements/Array.html",
    "href": "chapters_dir/2_storing_data_elements/Array.html",
    "title": "5  Array",
    "section": "",
    "text": "6 Numbers etc.\nLet’s think about this. Numbers have different way of getting represented. From Romans using letters (I, V, X, L, C, D, M) to Tally systems all were differnt ways of putting thought of ‘counts’ in written form.\nThis brings us to the point of representation of numbers.\nThe process of operating on different number representation is strongly associated with the need of grouping and reprenting larger numbers into compact forms. They key difference between these numbers is not just the symbol used for counts but also the value perceived from each symbol as shown in Table Table 6.1. [1]",
    "crumbs": [
      "2_storing_data_elements",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Array</span>"
    ]
  },
  {
    "objectID": "chapters_dir/2_storing_data_elements/Array.html#basic-matrix-multiplication",
    "href": "chapters_dir/2_storing_data_elements/Array.html#basic-matrix-multiplication",
    "title": "5  Array",
    "section": "6.1 Basic Matrix multiplication",
    "text": "6.1 Basic Matrix multiplication\nimport &lt;stdio.h&gt;\n\nReferences:\n\nnumerals and numeral systems\n\n\nReference: https://www.kodeco.com/books/metal-by-tutorials/v2.0/chapters/1-hello-metal\n\n6.1.1 What is rendering?\nThe processing of an outline image using color and shading to make it appear solid and three-dimensional.\nThe process of Metal rendering is much the same no matter the size and complexity of your app, and you’ll become very familiar with the following sequence of drawing your models on the screen:\n\n\n\n\n\n\nFigure 6.1: img\n\n\n\nSee Figure 6.1 for an illustration.\nimport PlaygroundSupport\nimport MetalKit\n//PlaygroundSupport lets you see live views in the assistant editor, and MetalKit is a\n//framework that makes using Metal easier\n\n//check for whether GPU is available\nguard let device = MTLCreateSystemDefaultDevice() else {\n  fatalError(\"GPU is not supported\")\n}\n\n\n/**\n This code configures an MTKView for the Metal renderer. MTKView is a subclass of\n NSView on macOS and of UIView on iOS. MTLClearColor represents an RGBA value\n — in this case, cream. The color value is stored in clearColor and is used to set the\n color of the view.\n \n */\nlet frame = CGRect(x: 0, y: 0, width: 600, height: 600)\nlet view = MTKView(frame: frame, device: device)\n\nview.clearColor = MTLClearColor(red: 1, green: 1, blue: 0.8, alpha: 1)\n\n\n\n/**\n Model I/O is a framework that integrates with Metal and SceneKit. Its main purpose\n is to load 3D models that were created in apps like Blender or Maya, and to set up\n data buffers for easier rendering.\n Instead of loading a 3D model, you’ll load a Model I/O basic 3D shape, also called a\n primitive. A 3D primitive is typically a cube, a sphere, a cylinder or a torus.\n */\n// 1\nlet allocator = MTKMeshBufferAllocator(device: device)\n// 2\nlet mdlMesh = MDLMesh(sphereWithExtent: [0.75, 0.75, 0.75],\n                      segments: [100, 100],\n                      inwardNormals: false,\n                      geometryType: .triangles,\n                      allocator: allocator)\n// 3\nlet mesh = try MTKMesh(mesh: mdlMesh, device: device)\n\nguard let commandQueue = device.makeCommandQueue() else {\n  fatalError(\"Could not create a command queue\")\n}\n\n/**\n Ideally shader file should be separate but for now we are going with string format\n */\nlet shader = \"\"\"\n#include &lt;metal_stdlib&gt; \nusing namespace metal;\n\nstruct VertexIn {\n  float4 position [[ attribute(0) ]];\n};\n\nvertex float4 vertex_main(const VertexIn vertex_in [[ stage_in ]]) {\n  return vertex_in.position;\n}\n\nfragment float4 fragment_main() {\n  return float4(1, 0, 0, 1);\n}\n\"\"\"\n\nlet library = try device.makeLibrary(source: shader, options: nil)\nlet vertexFunction = library.makeFunction(name: \"vertex_main\")\nlet fragmentFunction = library.makeFunction(name: \"fragment_main\")\n\nlet pipelineDescriptor = MTLRenderPipelineDescriptor()\npipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm\npipelineDescriptor.vertexFunction = vertexFunction\npipelineDescriptor.fragmentFunction = fragmentFunction\n\n\npipelineDescriptor.vertexDescriptor =\n     MTKMetalVertexDescriptorFromModelIO(mesh.vertexDescriptor)\n\nlet pipelineState =\n  try device.makeRenderPipelineState(descriptor: pipelineDescriptor)\n\n// 1\nguard let commandBuffer = commandQueue.makeCommandBuffer(),\n// 2\n  let renderPassDescriptor = view.currentRenderPassDescriptor,\n// 3\n  let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor:\n    renderPassDescriptor)\nelse { fatalError() }\n\nrenderEncoder.setRenderPipelineState(pipelineState)\n\nrenderEncoder.setVertexBuffer(mesh.vertexBuffers[0].buffer,\n                              offset: 0, index: 0)\n\nguard let submesh = mesh.submeshes.first else {\n  fatalError()\n}\n\n\nrenderEncoder.drawIndexedPrimitives(type: .triangle,\n                          indexCount: submesh.indexCount,\n                          indexType: submesh.indexType,\n                          indexBuffer: submesh.indexBuffer.buffer,\n                          indexBufferOffset: 0)\n\n\n// 1\nrenderEncoder.endEncoding()\n// 2\nguard let drawable = view.currentDrawable else {\n  fatalError()\n}\n// 3\ncommandBuffer.present(drawable)\ncommandBuffer.commit()\n\n\nPlaygroundPage.current.liveView = view",
    "crumbs": [
      "2_storing_data_elements",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Array</span>"
    ]
  },
  {
    "objectID": "chapters_dir/2_storing_data_elements/Matrix.html",
    "href": "chapters_dir/2_storing_data_elements/Matrix.html",
    "title": "6  Matrix",
    "section": "",
    "text": "6.0.1 Unified Memory\nIn order to get familiar with concept of unified memory, let’s think about how CPU and GPU works under the hood. Each time CPU or GPU are called with a task, there is a ‘quick’ memory which loads/reloads data from secondary memory to quick accessible memory i.e. RAM. This is more like bringing data closer to compute. Now traditionally, the CPU and GPU had their rescpective RAM memories but unified memory brought the concept of shared pool of memory between GPU and CPU.\nUnified Memory creates a pool of managed memory that is shared between the CPU and GPU, bridging the CPU-GPU divide. Managed memory is accessible to both the CPU and GPU using a single pointer. The key is that the system automatically migrates data allocated in Unified Memory between host and device so that it looks like CPU memory to code running on the CPU, and like GPU memory to code running on the GPU.\nSee Figure 6.1 for an illustration. src\n\n\n\n\n\n\n\nFigure 6.1: Unified Memory\n\n\n\n\n\n\n6.0.2 Diving into GPU programming.\nLet’s start with basic vector addition in C++.\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\nvoid add(int n,float *x ,float *y)\n{\n    for(int i = 0;i &lt;n; i++)\n    {\n        y[i] = x[i] + y[i];\n    }\n}\n\n\n\nint main (void)\n{\n    int N = 1&lt;&lt;20; //1M elements\n    \n    float *x = new float[N];\n    float *y = new float[N];\n    \n    for (int i =0; i&lt;N;i++)\n    {\n        x[i]=1.0f;\n        y[i]=2.0f;\n    }\n    \n    //add using cpu\n    add(N, x ,y);\n    // Check for errors (all values should be 3.0f)\n     float maxError = 0.0f;\n     for (int i = 0; i &lt; N; i++)\n       maxError = fmax(maxError, fabs(y[i]-3.0f));\n     std::cout &lt;&lt; \"Max error: \" &lt;&lt; maxError &lt;&lt; std::endl;\n     \n     // Free memory\n     delete [] x;\n     delete [] y;\n     \n     return 0;\n    }\n\nA quick run in local cpp environment . Refer this to setup C++ compiler on your local machine\ng++ matrix_mul.cpp -o add\n./add\nOutput:\nMax error: 0\nNow the naive addition let’s walk through the C++ code step by step to understand what it does and how it works.\n\nHeader Files\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\n#include &lt;iostream&gt;: Used for input and output, e.g., std::cout.\n#include &lt;math.h&gt;: Includes math functions like fabs() and fmax().\n\n\nFunction: add\nvoid add(int n, float *x, float *y)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        y[i] = x[i] + y[i];\n    }\n}\nThis function:\n\nTakes n elements of two float arrays: x and y.\nFor each index i, it adds x[i] to y[i] and stores the result back in y[i].\n\nSo, it’s adding vectors x and y element-wise, storing the result in y.\n\nMain Function\nint main (void)\nThe entry point of the program.\n\nStep 1: Declare and Allocate Memory\nint N = 1 &lt;&lt; 20; // 1 million elements\nfloat *x = new float[N];\nfloat *y = new float[N];\n\n1 &lt;&lt; 20 means 2^20 = 1,048,576.\nAllocates two arrays x and y of size 1 million using new.\n\n\nStep 2: Initialize Arrays\nfor (int i = 0; i &lt; N; i++)\n{\n    x[i] = 1.0f;\n    y[i] = 2.0f;\n}\n\nFills the x array with 1.0f and the y array with 2.0f.\nSo before addition:\n\nx = [1.0, 1.0, ..., 1.0]\ny = [2.0, 2.0, ..., 2.0]\n\n\n\nStep 3: Add Arrays Using CPU\nadd(N, x, y);\nCalls the add function:\n\ny[i] = x[i] + y[i] = 1.0 + 2.0 = 3.0 Now y = [3.0, 3.0, ..., 3.0]\n\n\nStep 4: Check for Errors\nfloat maxError = 0.0f;\nfor (int i = 0; i &lt; N; i++)\n    maxError = fmax(maxError, fabs(y[i] - 3.0f));\n\nChecks that each value in y is exactly 3.0.\nfabs(y[i] - 3.0f) measures the absolute error.\nfmax keeps the maximum error encountered.\nFor correct execution, maxError should be 0.0.\n\n\nStep 5: Print Result\nstd::cout &lt;&lt; \"Max error: \" &lt;&lt; maxError &lt;&lt; std::endl;\nPrints the maximum error (should be 0.0 if all additions were perfect).\n\nStep 6: Free Allocated Memory\ndelete [] x;\ndelete [] y;\n\nFrees the dynamically allocated memory to prevent memory leaks.\n\n\nNow to run this code on GPU cores (using Metal framework), it requires some changes.\n\n\n6.0.3 What exactly is a .metal file?\nA .metal file (aka shader) is Apple’s native built alternative to OpenGL (deprecated).\n\nThe first change is to create a .metal file. In the context of Apple GPUs, “metal file” typically refers to as Metal Shader (Metal Shader Language), which is a small program that runs on the GPU to perform rendering operations. MSL is a variant of C++ designed for GPU programming. In Metal, code that runs on GPUs is called a shader, because historically they were first used to calculate colors in 3D graphics. Metal is Apple’s low-level graphics API that allows developers to harness the full power of the GPU for various tasks, including rendering, image processing, and compute operations.\n\n#include &lt;metal_stdlib&gt;\nusing namespace metal;\n\nkernel void vector_add(\n    const device float *x [[buffer(0)]],\n    const device float *y [[buffer(1)]],\n    device float *result [[buffer(2)]],\n    uint id [[thread_position_in_grid]]\n) {\n    result[id] = x[id] + y[id];\n}\nUnpacking above program.\nStep 2: Set Up C++/Objective-C++ Host Code Save this as main.mm (note .mm for Objective-C++):\n#import &lt;Metal/Metal.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    const int N = 1 &lt;&lt; 20;\n\n    id&lt;MTLDevice&gt; device = MTLCreateSystemDefaultDevice();\n    id&lt;MTLCommandQueue&gt; queue = [device newCommandQueue];\n\n    // Load Metal library\n    NSError *error = nil;\n    NSString *path = @\"addVectors.metallib\"; // Precompiled Metal library\n    id&lt;MTLLibrary&gt; library = [device newLibraryWithFile:path error:&error];\n    id&lt;MTLFunction&gt; func = [library newFunctionWithName:@\"vector_add\"];\n    id&lt;MTLComputePipelineState&gt; pipeline = [device newComputePipelineStateWithFunction:func error:&error];\n\n    // Host arrays\n    std::vector&lt;float&gt; x(N, 1.0f), y(N, 2.0f), result(N);\n\n    // GPU buffers\n    id&lt;MTLBuffer&gt; xBuf = [device newBufferWithBytes:x.data() length:N * sizeof(float) options:0];\n    id&lt;MTLBuffer&gt; yBuf = [device newBufferWithBytes:y.data() length:N * sizeof(float) options:0];\n    id&lt;MTLBuffer&gt; resBuf = [device newBufferWithLength:N * sizeof(float) options:0];\n\n    id&lt;MTLCommandBuffer&gt; cmdBuf = [queue commandBuffer];\n    id&lt;MTLComputeCommandEncoder&gt; encoder = [cmdBuf computeCommandEncoder];\n    [encoder setComputePipelineState:pipeline];\n    [encoder setBuffer:xBuf offset:0 atIndex:0];\n    [encoder setBuffer:yBuf offset:0 atIndex:1];\n    [encoder setBuffer:resBuf offset:0 atIndex:2];\n\n    MTLSize gridSize = MTLSizeMake(N, 1, 1);\n    NSUInteger threadGroupSize = pipeline.maxTotalThreadsPerThreadgroup;\n    MTLSize threadgroupSize = MTLSizeMake(threadGroupSize, 1, 1);\n\n    [encoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize];\n    [encoder endEncoding];\n    [cmdBuf commit];\n    [cmdBuf waitUntilCompleted];\n\n    float *resData = (float *)resBuf.contents;\n    float maxError = 0.0f;\n    for (int i = 0; i &lt; N; i++) {\n        float err = fabs(resData[i] - 3.0f);\n        if (err &gt; maxError) maxError = err;\n    }\n    std::cout &lt;&lt; \"Max error: \" &lt;&lt; maxError &lt;&lt; std::endl;\n\n    return 0;\n}\n\n6.0.3.1 🏗️ Step 3: Compile and Run\n\n6.0.3.1.1 A. Compile the Metal shader:\nxcrun -sdk macosx metal -c addVectors.metal -o addVectors.air\nxcrun -sdk macosx metallib addVectors.air -o addVectors.metallib\n\n\n6.0.3.1.2 B. Compile the main program:\nclang++ -std=c++17 -framework Metal -framework Foundation main.mm -o vector_add\n\n\n6.0.3.1.3 C. Run it:\n./vector_add\nYou should see:\nMax error: 0\n\n\n\n\n\nMSL\n\n\n\n\n\n\n6.0.3.2 Template\n\n\n\n\n\n\n\n\nComponent\nPurpose\nChanges\n\n\n\n\n.metal shader\nRuns on GPU\nChange result[id] = ... logic\n\n\n.metallib\nCompiled shader\nRecompile when shader changes\n\n\nmain.mm\nHost-side driver\nUsually unchanged (optional name changes)\n\n\nclang++ + xcrun\nCompile tools\nis Fixed\n\n\n\n\nNow Let’s bind everything up as a resuable piece for plugging in metal shaders for other operations.",
    "crumbs": [
      "2_storing_data_elements",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "chapters_dir/scratching_the_surface/intro.html",
    "href": "chapters_dir/scratching_the_surface/intro.html",
    "title": "7  Understanding Metal Pipeline",
    "section": "",
    "text": "So let’s take it from the top.\n\n7.0.1 What exactly is a .metal file?\nA .metal file (aka shader) is Apple’s native built alternative to OpenGL (deprecated).\n\nThe first change is to create a .metal file. In the context of Apple GPUs, “metal file” typically refers to as Metal Shader (Metal Shader Language), which is a small program that runs on the GPU to perform rendering operations. MSL is a variant of C++ designed for GPU programming. In Metal, code that runs on GPUs is called a shader, because historically they were first used to calculate colors in 3D graphics. Metal is Apple’s low-level graphics API that allows developers to harness the full power of the GPU for various tasks, including rendering, image processing, and compute operations.\n\n\n\n\n\nMSL\n\n\nResources:\n\nyoutube video on how GPU’s work\n30 days of Metal\nApple docs\nApple Metal Language specification",
    "crumbs": [
      "Scratching the Surface",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Understanding Metal Pipeline</span>"
    ]
  }
]